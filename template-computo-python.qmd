# Motivation

## Bayesian workflow

@gelman2013bda begin their foundational textbook by factoring Bayesian data analysis into three steps.

1. Design a joint probability distribution for observable data and unobservable parameters.
2. Perform inference to generate a posterior sample over parameters conditioned on data.
3. Evaluate the model fit and what it tells us about our quantities of interest.

The authors further suggest that if the evaluation in step (3) is not sufficient, then one should go back to step (1) and try to come up with a better model.  More recently, @gelman2020workflow outlined a workflow for Bayesian analysis that puts more emphasis on evaluating multiple models simultaneously and transparently reporting their exploration and comparison.

A probabilistic programming language (PPL) primarily provides support for coding statistical models defined in step (1) in a way that they can be used for inference in step (2).  PPLs are typically coupled with samplers that allow step (2) to be performed with Monte Carlo methods.  PPLs are typically coupled with posterior analysis and model comparison tools for task (3).

In this paper, we are going to focus on performing the same function as a PPL without actually using a PPL.  We will also provide guidance on integration with tools for inference, model evaluation/criticism, and model comparison.  Our goal is to develop a methodology for implementing efficient and scalable differentiable Bayesian models in Python in a way that is both easy to code and easy to read.  

For step (2), we recommend the Python package Blackjax [@cabezas2024blackjax]. Blackjax includes implementations of Stan's primary inference methods, the no-U-turn sampler (NUTS) [@hoffman2014no], automatic differentiation variational inference (ADVI) [@kucukelbir2017automatic], and Pathfinder variational inference [@zhang2022pathfinder].  Blackjax is being actively maintained and extended, and already includes several other useful algorithms, including microcanonical (aka isokinetic) sampling [@robnik2025metropolis], sequential Monte Carlo (SMC) [@doucet2001introduction], elliptical slice sampling [@murray2010elliptical], generalized HMC (GHMC) [@horowitz1991generalized], and even random-walk Metropolis (RWM) [@hastings1970monte].

For step (3), we recommend the Python package Arviz [@kumar2019arviz].  Arviz provides state-of-the-art convergence monitoring using split, ranked $\widehat{R}$, estimation of bulk and tail effective sample sizes, standard errors, posterior means, standard deviations, and quantiles, as well as approximate leave-one-out (LOO) cross-validation [@vehtari2021rank; @vehtari2017practical].

## Why not just use Stan?

Stan [@carpenter2017stan] is a domain-specific language for expressing differentiable probability densities and posterior predictive quantities.  Stan is a probabilistic programming language in the sense that its variables can be interpreted as random variables.  Stan has been used in almost every area where statistics is applied, and as such, has accumulated an unmatched depth and breadth of training materials around different classes of probabilistic models.  There are textbooks, college classes, and reproducible case studies in all of these areas.  There's a vibrant community with a high volume [discussion forum](https://discourse.mc-stan.org).  The language is still being expanded and so is it's math library.

The Stan project introduced several state of the art gradient-based inference algorithms including the no-U-turn sampler (NUTS) [@hoffman2014no], automatic differentiation variational inference (ADVI) [@kucukelbir2017automatic], Pathfinder variational inference [@zhang2022pathfinder], and black-box nested Laplace approximations [@margossian2023general] as well as posterior analysis tools such as split- and ranked-$\widehat{R}$ and corresponding bulk and tail effective sample size [@vehtari2021rank], leave-one-out cross-validation [@vehtari2017practical], refined simulation-based calibration checks [@talts2018validating], and prior predictive checks [@gabry2019visualization].  It is often used as the basis of methodological developments such as Bayesian workflow [@gelman2020workflow].
 
So why not just use Stan? The first reason is that Stan is largely CPU-bound.  All of its analysis tools and algorithms run on the CPU.  Although there are ways to call individual functions in a Stan program on the GPU (e.g., Cholesky decomposition) and ways to apply map-reduce across multiple cores, this is not enough.  Stan lacks a way to keep computation in-kernel on the GPU or organize inference to enable single-instruction multiple-data (SIMD) parallelism.  Although Stan has been faster than JAX on CPU, it is not competitive on modern hardware [@sountsov2024running; @maskell2024jaxgpu].

The second obstacle to using Stan is the need to learn a second language. While Stan is not particularly complicated, it does present several additional difficulties beyond unfamiliar syntax and semantics.

* Stan is indexed from 1, like much of mathematics and in particular, linear algebra, whereas Python is indexed from 0, like most programming languages.  Translating between 0-based and 1-based indexing is tedious, error-prone, and obfuscates code.
* Stan is strongly typed and statically compiled, which has the benefit of being type-safe at run time and leads to fast C++ computation.  The downside is that this kind of static typing is unfamiliar to most of Stan's intended users.  Stan's typing can be an annoyance and performance bottleneck even for experienced programmers due to its poor representational choice for containers that mixes C++ standard vectors [@josuttis2012cpp] for arrays and Eigen matrices [@guennebaud2010eigen] for linear algebra (this may sound harsh, but it was our fault as the original developers of Stan).
* Stan requires a scripting language like R, Python, and Julia, to combine modeling with data preparation and posterior analysis, rather than providing a seamless single-language experience.  The interface between these languages and Stan is minimal---Stan is just being called as a black box to return samples.
* There is relatively little tooling to aid with Stan development.  Currently, it's just autocomplete, syntax highlighting, and debug-by-print.  Python, in contrast, has several well supported integrated development environments with tooling for debugging, generating notebooks, integration with chatbots, integration with documentation, automatic refactoring tools, etc.
* While there is a great deal of tutorial and onboarding material for Stan, it has to split its attention among several interfaces (two interfaces in R and Python and one in Julia).  Taken together, even Stan's extensive documentation is dwarfed by the pedagogical material around scientific, differentiable, and probabilistic computing in Python.  


## Why not just use PyMC or NumPyro?

The very first probabilistic programming language of which we are aware is BUGS (Bayesian inference using Gibbs Sampling) [@lunn2009bugs; @lunn2012bugs], which was released way back in 1991.  In BUGS, Bayesian models are specified with deterministic and stochastic nodes arranged in a directed acyclic graph.  Each node was either input as data, or defined as a (possibly stochastic) function of its direct ancestors in the graph.  This enabled a BUGS model to be used to infer any of the stochastic variables in the model given values for the data nodes and all other stochastic nodes.  This provides a clean way to perform analyses such as prior predictive inference and posterior predictive inference automatically through the graphical structure of the model.  BUGS samples using generalized Gibbs sampling, which does not scale well in dimension.

PyMC [@salvatier2016probabilistic] and NumPyro [@phan2019composable] are Python packages that take a directed graphical modeling approach to specifying Bayesian models and are capable of generating JAX code as output.  There are similar packages in other languages, but they do not generate JAX code.  JAGS [@plummer2003jags] is a standalone language that reimplements and extends BUGS and is typically used through R, NIMBLE [@de2017programming] is coded in R, and Turing.jl [@ge2018turing] is coded in Julia.

Like Stan, all of the modern PPLs efficiently scale in dimension by using gradient-based inference methods.  Like BUGS, they are able to exploit the graphical model structure directly to automate a number of functions that are painful to code in Stan and will largely remain painful to code in what we are proposing here, such as prior and posterior predictive checks and simulation-based calibration, and at least in the case of PyMC, general patterns of missing data.

When models get more complicated in terms of novel parameter constraints, densities, conditional structures, etc., both PyMC and NumPyro provide escape hatches to let you define transformations and log densities directly in the same way as Stan. This feels dirty in the same way as using "ones-trick" in BUGS [@lunn2012bugs]. And while it is great for allowing general models to be defined, it defeats all the benefits of having a clean generative graphical model in the first place.  At the point models start getting more complicated, we believe it is more straightforward to code the models directly in JAX rather than working around the graphical modeling paradigm of PyMC or NumPyro.

A second reason to prefer the approach we are presenting here is that it is much more direct.  By that, we mean that like Stan, the resulting code is implemented transparently in an imperative fashion rather than indirectly through the structure of the directed acyclic graph.

## Special function support in JAX

Stan has an extensive library of special mathematical and statistical functions, as well as restructuring functions for arrays and matrices.  Many of these are needed to differentiate cumulative distribution functions and to define custom densities.  Here's a brief overview of the coverage available in JAX compared to Stan.  The bottom line is that support for special functions is deeper in JAX.

* *Matrix library*:  This is JAX's main focus and it far exceeds Stan's collection of familiar matrix functions and reshaping tools by punning NumPy ([`jax.numpy`](https://docs.jax.dev/en/latest/jax.numpy.html)) and SciPy ([`jax.scipy`](https://docs.jax.dev/en/latest/jax.scipy.html)).  There is even limited (and experimental) support for sparse matrices and solvers natively ([`jax.experimental.sparse`](https://docs.jax.dev/en/latest/jax.experimental.sparse.html)).

* *Special functions*:  These are available all over the JAX ecosystem, including in JAX's NumPy and SciPy modules.  The differentiable SciPy module ([`jax.scipy.special`](https://docs.jax.dev/en/latest/jax.scipy.html#module-jax.scipy.special)) is not complete compared to SciPy.  The deficit is more than made up by the special function library provided by TensorFlow Probability (TFP) ([`tfp.math`](https://www.tensorflow.org/probability/api_docs/python/tfp/math)) and maintained by Google.  For example, the Lambert W function available in Stan has not been ported from SciPy but is available through TFP.  The bottom line is that JAX provides a *better* selection of well supported special functions.

* *Probability distributions*:  Stan implements dozens of probability distributions, including almost most (but not all) of the ones in common use for statistical models.  While the basics are available through JAX's NumPy and SciPy modules (often redundantly), the go-to library TFP ([`tfp.probability`](https://www.tensorflow.org/probability?hl=en)) for probability-related functions (e.g., probability density functions, probability mass functions, and cumulative distribution functions).  In some cases, there are also quantile functions, which are poorly supported in Stan.  The bottom line is that the native Google-supported *JAX* ecosystem provides a *better* selection of well supported probability functions and random number generators.  There is even wider support beyond native JAX and TensorFlow, including the probabilistic programming language NumPyro [@phan2019composable] and Google DeepMind's library Distrax [@deepmind2020jax].

* *Complex-valued functions*: JAX and Stan both have core library support for complex-valued functions built-in, including fast Fourier transforms and complex matrix operations.

* *Neural networks*: JAX is integrated tightly with a range of neural network constructions through the Flax package [@heek2020github], which is maintained by a team at Google DeepMind, but is not an official Google product like TensorFlow or JAX.  It supports everything from simple multilayer perceptrons and convolutional neural networks to autoencoders and multi-head attention.

* *Simulation-based inference (SBI)*: There is as of yet, no mature and commonly used SBI package in JAX, nor is there any support in Stan.
    
* *Implicit Solvers*:  Applied statistics often requires equations to be solved and differentiated and Stan provides a fairly extensive library.
    * *Ordinary differential equation (ODE) solvers*: There is no built-in support in JAX for ODE solvers, but the Diffrax package [@kidger2021on] is widely used and provides the same kind of adjoint and analytic methods as Stan that provide sensitivity analysis without automatically differentiating through the algorithm.  

    * *Root finders*:  There is no built-in support in JAX for root finders, but the JAXOpt package [@blondel2021jaxopt] is maintained by Google and provides a range of solvers including the Newton method used by Stan.

    * *1D Integration*: These functions are useful for defining cumulative distribution functions for novel densities. There is no built-in or widely used external support for 1D integration in JAX at the moment. This is the only problem for which Stan has a solution, but JAX has none.
    
    * *Hidden Markov models*:  TFP (through [`tfp.distributions.HiddenMarkovModel`](https://www.tensorflow.org/probability/api_docs/python/tfp/distributions/HiddenMarkovModel?hl=en)) provides support for the forward algorithm to compute the distribution of outcomes given parameters (i.e., implement a likelihood function). This is enough to fit models out of the box, but it is not as efficient as the full forward-backward algorithm in Stan.
    
    * *Kalman filters*:  There is no direct support in Stan; there is experimental support in TFP (in [`tfp.experimental.parallel_filter.kalman_filter`](https://www.tensorflow.org/probability/api_docs/python/tfp/experimental/parallel_filter/kalman_filter?hl=en)).
    
    * *Partial differential equation (PDE) solvers*:   Stan has no support for partial differential equations.  The JAX-CFD package [@kochkov2021cfd] from Google, mostly focused on fluid dynamics, includes a number of general-purpose PDE solvers, including finite volume/difference methods, pseudospectral methods, and machine-learning methods.  It supports Navier-Stokes, advection-diffusion, period and wall boundary conditions, and runs on GPU and TPU with gradients.

    * *Stochastic differential equation (SDE) solvers*:  Stan has no support for stochastic differential equations. The Diffrax package [@kidger2021on], in addition to providing stiff ODE solvers, also supports traditional SDE and SPDE solvers (Eueler-Maruyama, Milstein, Stratonovich/It√¥) through spatial discretization.



Other than the omission of 1D integration and the backward pass of the forward-backward algorithm, the special function and probability distribution and transform libraries of JAX are *better* than those supplied by Stan, with the caveat that users may need to search multiple places to find what they are looking for in more specialized cases.  When it comes to even more complicated functions like PDE and SDE solvers and neural networks, Stan isn't even in the game.  The JAX-based PPL NumPyro can also make use of these JAX packages in many cases, especially if users are willing to forego its underlying graphical model abstraction.


## Constrained parameter support in JAX

Stan provides built-in transforms for constrained parameters to provide densities with support over all of $\mathbb{R}^D$, along with the corresponding change-of-variables adjustments.  These are custom implementations with analytic Jacobian-adjoint product gradients and vectorized application to containers.

The Oryx transform library in TensorFlow is built on top of the TFP bijector library ([`tfp.bijectors`](https://www.tensorflow.org/probability/api_docs/python/tfp/bijectors)) [@dillon2017tensorflow], which can also be used directly.  TFP bijectors provide all of the transforms provided by Stan and many more including softplus, various cdfs and hyperbolic tangent as replacements for inverse-logit, more multivariate transforms such as cumulative sums and Householder factorizations, as well as trained transforms like RealNVP normalizing flows [@dinh2016density].  Oryx additionally allows transforms to be written down directly in such a way that Oryx can automatically calculate inverse transforms and Jacobian determinants of inverse transforms.

## Modularity in JAX

SlicStan [@gorinova2019slic] reconceived Stan without blocks---the sorting into data, parameters, and generated quantities was carried out by data flow analysis.  The primary motivation was to make it possible to modularly express concepts like a hierarchical prior.  With Stan itself, this is impossible unless the modularity is in the form of a simple function.  With SlicStan, the parameters, priors, etc., could all be constructed modularly and reused.  By allowing models to be expressed directly in Python code, NumPyro and PyMC already support modular code reuse.  Although it is rare to see this feature used in example code, it is widely used in production.

By coding models directly in Python, we gain the same benefits of NumPyro and PyMC.  We can write general programs returning arbitrary components of a probabilistic program and combine them at will.  We will provide examples below.


# Bayesian inference

In this section, we will lay out the precise definition of the Bayesian inference problem we are trying to compute, show how it can be computed asymptotically exactly using Monte Carlo methods, and apply some simple calculus to transform parameterizations to be unconstrained (i.e., have support over all of $\mathbb{R}^D$).  

## Bayesian models

A Bayesian model is nothing more than a joint distribution over parameters $\theta$ and data $y$.  By the chain rule, the posterior distribution of the parameters given the data is given by $p(\theta \mid y) \propto p(\theta, y)$.  Often our density is factored into a prior times a likelihood, $p(\theta \mid y) = p(\theta) \cdot p(y \mid \theta)$, but nothing in Stan or what we are proposing for JAX presupposes a clean factorization.  In fact, our methods can be used to sample from any old density---it doesn't have to arise as a Bayesian posterior.

## Bayesian inference with posterior expectations

Bayesian inference involves visualizing and summarizing quantities of interest in the posterior and posterior predictive distributions.  For summaries, we are typically interested in either posterior averages or posterior quantiles of a function of the parameters.  Quantiles are typically used to give us medians and uncertainty intervals, while averages give us everything else. By averaging estimates of quantities of interest derived from parameters weighted by posterior density, we can account for estimation uncertainty into account in our inferences. 

Averages over the posterior density are most naturally expressed using expectation notation.  Given a random variable $\Theta \in \mathbb{R}^D$ representing knowledge about the paraemters, the expectation of a function $f:\mathbb{R}^D \rightarrow \mathbb{R}$ is given by
$$
\mathbb{E}[f(\Theta) \mid y]
= \int_{\mathbb{R}^D} f(\theta) \cdot p(\theta \mid y) \, \textrm{d}\theta.
$$
The rest of this section provides examples of common functions whose expectations are evaluated for Bayesian inference.

The parameter estimate that minimizes expected square error, assuming the model is correct, is the posterior mean,
$$
\widehat{\theta} = \mathbb{E}[\Theta \mid y].
$$
This is just taking the function $f$ to be the identity.  The posterior covariance is
$$
\textrm{var}[\Theta \mid y] = \mathbb{E}[(\Theta - \widehat{\theta}) \cdot (\theta - \widehat{\theta})^\top].
$$
Here the function is $f(\theta) = (\theta - \widehat{\theta}) \cdot (\theta - \widehat{\theta})^\top.$.  

If we have an event $A \subseteq \mathbb{R}^D$, then its probability is given by the expectation of its indicator function,
$$
\Pr[\theta \in A \mid y] = \mathbb{E}[\mathbb{1}_A(\theta \in A) \mid y].
$$

If we want to evaluate posterior predictive densities $p(\tilde{y} \mid y)$ for new data $\tilde{y}$, this can be expressed as an expectation,
$$
p(\tilde{y} \mid y) = \mathbb{E}[p(\tilde{y} \mid \theta) \mid y].
$$

## Computation with Markov chain Monte Carlo methods

We can reduce the high-dimensional integration problem to one of sampling from the posterior,
$$
\theta^{(m)} \sim p(\theta \mid y).
$$
Given modest assumptions to ensure ergodicity [@roberts2004mcmc], the Monte Carlo estimate converges to the true value,
$$
\mathbb{E}[f(\theta) \mid y]
= \lim_{M \rightarrow \infty} \
  \frac{1}{M} \sum_{m < M} f(\theta^{(m)}).
$$
In practice, we use a finite approximation for a fixed $M$,
$$
\mathbb{E}[f(\theta) \mid y]
\approx  \frac{1}{M} \sum_{m < M} f(\theta^{(m)}).
$$
If the Markov chain is well behaved (e.g., it's geometrically ergodic), then the Markov chain central limit theorem will hold, and the Monte Carlo estimate will converge to the true value at a rate of $\mathcal{O}(1 / \sqrt{M})$ [@roberts2004mcmc].

## Unconstrained parameterizations

It is much easier to define a sampling algorithm for situations where the posterior has support over all of $\mathbb{R}^D$, i.e., for all $\theta \in \mathbb{R}^D$, $p(\theta \mid y) > 0$.  Stan and other PPLs transform any unconstrained parameters to be unconstrained.  Then in practice, the unconstrained parameters are inverse transformed to satisfy their constraints.  This requires an adjustment for the change of variables, which happens implicitly in PPLs.  Stan requires all parameter constraints to be declared; the graphical modeling sublanguage of PyMC and NumPyro infer these constraints from the distributions in which variables participate (e.g., if a variable is given a Wishart distribution, it must be a symmetric and positive definite matrix).

Mathematically, given a constrained random variable $\Theta \in C \subseteq \mathbb{R}^D$, with a density $p_\Theta(\theta)$, and a smooth bijection $f:C \rightarrow \mathbb{R}^N$, we can derive the density of $\Phi = f(\Theta)$ as
$$
p_\Phi(\phi) = p_\Theta(f^{-1}(\phi)) \cdot \left| \nabla f^{-1}(\phi) \right|,
$$
where $|\cdot|$ denotes the absolute determinant operator and $f^{-1}$ is the inverse of $f$.  In the univariate case, $\nabla f^{-1}(y)$ reduces to the derivative of the inverse transform at $y$ (i.e., $\nabla f^{-1} = (f^{-1})'$).

If there is a sequence of variables being transformed one at a time, the overall Jacobian will be block diagonal, with an absolute Jacobian determinant equal to the product of the absolute Jacobian determinants of the blocks.  Unconstrained parameters are transformed by the identity, which has a unit Jacobian determinant.  This makes it particularly simple to work on the unconstrained scale---we just map unconstrained parameters back to the constrained space using the inverse transforms and add the log absolute determinants of their Jacobians.  For maximum likelihood estimation, the Jacobians can be dropped from the target density with a flag.

Stan supplies constraints for variables that are lower bounded (for scales), upper bounded (for log probabilities), range bounded (for probabilities), affine transforms (for non-centered parameterizations), ordered vectors (for cutpoints in ordinal regressions or identifying mixtures), unit vectors (for points on a hypersphere), simplexes (for categorical probability distributions), sum-to-zero vectors (for identifying varying effects), positive-definite symmetric matrices and their Cholesky factors (for covariance or precision matrices), and for unit-diagonal positive-definite matrices and their Cholesky factors (for correlation matrices). The Oryx package, which is native to JAX and built on top of the TensorFlow Probability bijectors package [@dillon2017tensorflow], provides an even wider range of useful transforms than Stan (e.g., softplus, alternative sigmoid cdfs, tanh, autoregressions, and flows, and many many more).


# Coding models in Stan

To ground the discussion, let's consider the concrete example of coding a linear regression and using it to predict new observations.

## A multivariate linear regression model

We will assume a very simple multivariate regression formulation with an intercept, $P \in \mathbb{N}$ covariates, and $N \in \mathbb{N}$ observations.  Our data is made up of observations $y_n \in \mathbb{R}$ paired with covariates $x_n \in \mathbb{R}^{N \times P}$.  We will assume the usual parameters consisting of a slope $\alpha \in \mathbb{R}$, regression coefficients $\beta \in \mathbb{R}^P$, and an error scale $\sigma \in (0, \infty)$.  We will assume the data and covariates are unit scale so that we can assume a weakly informative prior independently over our paraemters,
$$
\alpha \sim \textrm{normal}(0, 5)
\qquad
\beta_p \sim \textrm{normal}(0, 2.5)
\qquad
\sigma \sim \textrm{exponential}(0.5).
$$
We then add the conventional data generating process with independent normal errors, 
$$
y_n \sim \textrm{normal}(\alpha + x_n \cdot \beta, \sigma).
$$
The joint density defining our Bayesian model (with data $x$ taken as an unmodeled constant) is thus
$$\textstyle
\begin{array}{rcl}
p(y, \alpha, \beta, \sigma \mid x)
& = &
  \textrm{exponential}(\sigma \mid 0.5)
  \cdot \textrm{normal}(\alpha \mid 0, 5)
\\[4pt]
& & {} \cdot \left( \prod_{p=1}^P \textrm{normal}(\beta_p \mid 0, 2.5) \right)
  \cdot \left( \prod_{n=1}^N \textrm{normal}(y_n \mid \alpha + x_n \cdot \beta, \sigma) \right).
\end{array}
$$
Bayes's rule allows us to use the joint density as an unnormalized posterior,
$$
p(\alpha, \beta, \sigma \mid y, x)
\propto p(y, \alpha, \beta, \sigma \mid x).
$$

The only constrained parameter is $\sigma > 0$.  We transform positive-constrained parameters using the log transform, i.e., $\sigma^\textrm{unc} = \log \sigma$. The inverse transform is the exponential. Applying the change-of-variables formula and using the fact that $\left| \nabla \exp(u) \right| = |\exp'(u)| = \exp(u)$, the corresponding unconstrained density is
$$
p^\textrm{unc}(\alpha, \beta, \sigma^\textrm{unc} \mid x, y)
= p(\alpha, \beta, \exp(\sigma^\textrm{unc}) \mid x, y) \cdot \exp(\sigma^\textrm{unc}).
$$
On the log scale where we operate to prevent underflow and maintain precision, we have
$$
\log p(\alpha, \beta, \sigma^\textrm{unc} \mid x, y)
= \log p(\alpha, \beta, \exp(\sigma^\textrm{unc}) \mid x, y) + \sigma^\textrm{unc}.
$$


## Coding a linear regression in Stan

Here's an example Stan program defining a linear regression, which we have placed into the file `linear-regression.stan`. 
```stan
data {
  int<lower=0> N, N_new, P;
  matrix[N, P] x;
  vector[N] y;
  matrix[N_new, P] x_new;
}
parameters {
  real alpha;
  vector[P] beta;
  real<lower=0> sigma;
}
model {
  alpha ~ normal(0, 5);
  beta ~ normal(0, 2.5);
  sigma ~ exponential(0.5);
  y ~ normal(alpha + x * beta, sigma);
}
generated quantities {
  array[N_new] real y_new = normal_rng(alpha + x_new * beta, sigma);
}
```

Stan is very flexible.   For example, if `y` were binary data and we wanted to fit a logistic regression, `y` would be declared as `array[N] int<lower=0, upper=1>` and `normal()` would be replaced with `bernoulli_logit()` (and similarly for the generated quantities).

To ease the transition to JAX, note that the distribution statements in the model block are just syntactic sugar for incrementing the log target density [@carpenter2017stan].  The model block could have been coded as follows to generate the same C++ code.

```stan
  target += normal_lupdf(alpha | 0, 5);
  target += normal_lupdf(beta | 0, 2.5);
  target += lognormal_lupdf(sigma | 0, 1);
  target += normal_lupdf(alpha + x * beta, sigma);
```

Here, the `_lupdf` indicates a log (`l`), unnormalized (`u`), probability density function (`pdf`).  For probability mass functions, replace `pdf` with `pmf`; to preserve normalizing constants, drop the `u`.


## Simulating data

The sizes and covariates $x$ cannot be simulated from the model as they are not modeled.  We'll have to invent a distribution for those in order to simulate data, and we'll take $p=2$ and generate standard normal variates $x_{0:N, 0} \sim \textrm{normal}(0, 1)$, and take $x_{0:N, 1} \sim \textrm{chiSq}(1)$ by squaring a standard normal variate.

```{python python-code}
#| code-fold: false
import json
import numpy as np

def simulate_regression(n=128, p=2, n_new=4, seed=145777):
    def simulate_covariates(n):
      x = rng.normal(size=(n, p))
      x[:, 1] = x[:, 1]**2
      return x

    rng = np.random.default_rng(seed)
    alpha = rng.normal(0.0, 5.0)
    beta = rng.normal(0.0, 2.5, size=p)
    sigma = rng.exponential(1.0 / 0.5)
    x = simulate_covariates(n)
    mu = alpha + x @ beta
    y = rng.normal(mu, sigma)
    x_new = simulate_covariates(n_new)
    parameters = { "alpha": alpha, "beta": beta, "sigma": sigma }

    data = {
        "N": n, "P": p, "N_new": n_new, "x": x.tolist(),
	"y": y.tolist(), "x_new": x_new.tolist(),
    }
    return parameters, data

params, data = simulate_regression()
```

The simulated parameter values are as follows.

```{python python-code}
#| code-fold: false
print(f"alpha:{params['alpha']:6.2f};   beta[0]:{params['beta'][0]:6.2f};   beta[1]:{params['beta'][1]:6.2f};   sigma:{params['sigma']:6.2f}")
```

It's always a good idea to plot your data when possible.  We provide a plot of training data $y$ as a function of $x$ in @fig-sim-expected-y and @fig-sim-observed-x.

```{python python-code}
#| code-fold: true
#| fig-cap: "*A heatmap plot of `y = alpha + x @ beta` vs. `x` over 4 marginal standard deviations. The horizontal axes show the covariates `x` and the color represents $y$.*"
#| label: fig-sim-expected-y

import pandas as pd
import plotnine as pn
pn.options.set_option("figure_format", "png")
pn.options.set_option("figure_size", (10, 6))

alpha, beta = params['alpha'], params['beta']
x1_lim=(-4.0, 4.0)
x2_lim=(0.0, 16.0)
n=201
beta = np.asarray(beta, dtype=float).reshape(-1)
x1_grid = np.linspace(x1_lim[0], x1_lim[1], n)
x2_grid = np.linspace(x2_lim[0], x2_lim[1], n)
x1_mesh, x2_mesh = np.meshgrid(x1_grid, x2_grid, indexing="xy")
mu = float(alpha) + beta[0] * x1_mesh + beta[1] * x2_mesh
grid_df = pd.DataFrame({ 'x1': x1_mesh.ravel(),
                         'x2': x2_mesh.ravel(),
                         'mu': mu.ravel() })
plot_expected_y = (
    pn.ggplot(grid_df, pn.aes("x1", "x2", fill="mu"))
    + pn.geom_raster()
    + pn.labs(x="x[ : , 0]", y="x[ : , 1]",
              fill="E[y | x]", title="Expected value surface")
)
plot_expected_y.show()
```

```{python python-code}
#| code-fold: true
#| fig-cap: "*Observed values of $x$ in the simulation.*"
#| label: fig-sim-observed-x

x = np.asarray(data["x"], dtype=float)
obs_df = pd.DataFrame({"x1": x[:, 0], "x2": x[:, 1]})
plot_observed = (
    pn.ggplot(obs_df, pn.aes("x1", "x2"))
    + pn.geom_point(size=1.5, alpha=0.7)
    + pn.labs(x="x[ : , 0]", y="x[ : , 1]",
              title="Observed x values")
)
plot_observed.show()
```



# Sampling with Stan

Now that we have defined a Stan program and simulated data, we can perform inference based on the simulated data (pretending that we did not already know the parameters).  We will use Stan's defaults, which uses the multinomial no-U-turn sampler [@hoffman2014no,@betancourt2017conceptual] for fitting in four chains, with 1000 warmup and 1000 sampling iterations.

## The CmdStanPy interface

We will use the Python interface CmdStanPy [@stan2024csp], which makes an external system call to the reference command-line interface, CmdStan.    Before that, we import the cmdstanpy package and make sure we have a compiled CmdStan installation and turn the logging level down to `ERROR` so that our output isn't cluttered with progress messages.

```{python python-code}
#| code-fold: false
import cmdstanpy as csp
csp.install_cmdstan()
```


```{python python-code}
import logging
csp.utils.get_logger().setLevel(logging.ERROR)
```

## Transpilation, compilation, and sampling

Once we've done that, fitting is a two-liner that first transpiles the Stan program to C++ and compiles the C++ code.  

```{python python-code}
#| code-fold: false
m = csp.CmdStanModel(stan_file="linear-regression.stan")
```

Then it calls the sampler.  


```{python python-code}
#| code-fold: false
fit = m.sample(data=data, show_progress=False)
```

The variable `data` was defined above in the simulation.  The call to `sample()` uses CmdStanPy's default configuration parameters.  By default, Stan uses the multinomial, biased-progressive no-U-turn sampler [@betancourt2017conceptual], which invokes three stages of warmup (finding the bulk of the probability mass, estimating the inverse mass matrix, and estimating the step size). By default, Stan runs 1000 warmup and 1000 sampling iterations in 4 independent chains---this is often more than are necessary for model development and many applications.

## Posterior summaries with CmdStanPy and ArviZ

Now that we have the fit, we can print a summary of the posterior from CmdStan, limiting the number of significant figures based on the number of draws.  

```{python python-code}
#| code-fold: false
summary_csp = fit.summary(sig_figs=3)
print(summary_csp)
```
The first column lists all the variables of interest in the model, with `lp__` denoting the unnormalized log posterior density.  The remaining columns are defined per variable and include the posterior mean, Monte Carlo standard error, posterior standard deviation, mean absolute deviation (like standard deviation for medians), three quantiles (5\%, 50\%, and 95\%), as well as some convergence diagnostics.  The rank-normalized $\widehat{R}$ statistic is reported in the last column, and the effective sample size in the bulk and tail of the density, as well as bulk effective sample size per second (where we see this all ran quickly); definitions of all of these can be found in @vehtari2021rank.

This summary shows that the model fits very well.  While it doesn't report timing, the effective sample size per second statistic lets you infer that this all ran in less than 0.1s.  The $\widehat{R}$ statistics are all below 1.005 and the effective sample sizes are all above 2000 with 4000 total sampling draws across four chains.

Roughly the same summary can be achieved using the standalone package ArviZ, which shares many developers with Stan.

```{python python-code}
#| code-fold: false
import arviz as az

fit_xr = fit.draws_xr()
summary_az = az.summary(fit_xr)
print(summary_az)
```

The main difference is that ArviZ defaults to reporting 94% highest density intervals rather than traditional central intervals based on quantiles.  ArviZ can be configured to include Stan's quantile output, if desired and the highest-density interval changed to 90% coverage to match Stan's output using NumPy's quantile functions.

```{python python-code}
#| code-fold: false
summary_az_stan = az.summary(
    fit_xr,
    hdi_prob=0.9,
    stat_funcs={
        "q5": lambda x: np.quantile(x, 0.05),
        "q50": lambda x: np.quantile(x, 0.50),
        "q95": lambda x: np.quantile(x, 0.95),
    },
    extend=True
)
print(summary_az_stan)
```


# Stan to C++ transpilation

A Stan program translates almost line-for-line to a C++ class that implements all the interfaces around a model required for log density evaluation, posterior predictive quantity generation, and variable transforms [@stan2025ref].

## Stan's block structure

* *Functions block*: Each function in the functions block is translated to a C++ function that is templated flexibly enough to allow automatic differentiation.   The main limitation to Stan's functions is that they cannot cross blocks and they cannot introduce block-level variables such as data or parameters; a secondary limitation is that arguments must be real or integer based.  Thus it is not possible to define functions like the built-in ODE solvers that take functions as arguments.

* *Data and transformed data blocks*:  Each data declaration in the data block is translated to an instance variable of the generated class.  The data block can only contain declarations, and thus behaves like the signature for the data ingestion function.  The transformed data block is executed after the data is read in as the model object is being constructed.  After the model object is constructed with the data, it remains immutable to allow safe multi-threaded application.

* *Parameter and transformed parameter blocks*:  The log density function is defined for unconstrained inputs gathered into a vector.  The first part of the function unpacks the entries of that vector, applies the constraining transform to define constrained variables locally, then adds the log Jacobian determinant to the Jacobian accumulator to adjust for the change-of-variables making up the constraint.  Transformed  parameters also define local variables.  Everything executes serially as coded in the Stan program.

* *Model block*: The rest of the body of the log density function is the line-by-line translation of Stan's model block.  Each distribution and target increment statement increments the log density accumulator, which is returned as the value of the function.  Everything is templated generally enough and coded in the underlying math library to allow automatic differentiation;  the automatic differentiation code dominates the project in terms of size and presents the most challenges to developer recruitment because of its modern C++ architecture [@carpenter2015ad].

* *Generated quantities block*: This block is motivated by the goal of providing efficient forward-simulated predictive inferences.  The generated quantities block translates to a function that maps the parameters and a random number generator to the variables of interest.  These are gathered by this function along with the parameters and transformed parameters to form vector output.  The names of all the parameters define the columns of output and output is on the constrained scale where the user and Stan program model block operate.


## Stan's transpiled C++ model class

Stan programs are transpiled to C++, and then the C++ is compiled down to machine instructions.  The C++ class generated for the model has the following signatures, which have been simplified to remove debugging traces, template traits restrictions, and some fine-grained control parameters.  This is the same interface as is exposed by BridgeStan in Python, R, Julia, C, and Rust [@roualdes2023bridgestan].

```cpp
namespace lr_model_namespace {

class lr_model : model_base<lr_model> {
  // data, transformed data
  int N, N_new, P;    MatrixXd x;
  VectorXd y;         MatrixXd x_new;

  // read data from c, compute transformed data
  linear_regression_model(var_context& c, int seed,
                          ostream* msgs);

  // log densitye type T, propto drops constants, jacobian adjusts
  template <bool propto, bool jacobian, typename T>
  Vector<T> log_prob(Vector<T>& params, ostream* msgs) const;

  // evaluate generated quantities and write csv
  void write(RNG& rng, const VectorXd& params,
             ostream* csv_stream) const;

  
  string model_name() const noexcept;

  void unconstrain(const VectorXd& constrained_params,
                   VectorXd& unconstrained_params) const;
  void constrain(var_context& vars, VectorXd& constrained_params,
                 ostream* msgs) const;

  void param_names(vector<string>& names) const;
  void constrained_param_names(vector<string>& names) const;
};
} // lr_model_namespace

// global namespace factory for lr_model
model_base& new_model(var_context& c, int seed, ostream* msgs);
```

The data variables are specified in the `data` block in the Stan program.  Here, we have the sizes, the covariate matrices (`x` plus `x_new` for posterior prediction), and the outcomes (`y`).  The constructed C++ class is immutable and provides several methods, the most central of which is an unconstrained (in the sense of having support over all of $\mathbb{R}^D$) log density function that is templated in order to support automatic differentiation [@carpenter2015ad].  In math, the constraining transform maps $(\alpha, \beta, \sigma^\text{u})$ to $(\alpha, \beta, \exp(\sigma^\text{u}))$.  The transforms are independent and the first two are the identity, so the Jacobian determinant works out to $\exp(\sigma^\text{u})$.  Thus the additive change-of-variables adjustment on the log scale is just $\log \exp(\sigma^\text{u}) = \sigma^\text{u}$.

The model block defines a density function $p$ over constrained parameters.  Although Stan can be used to sample from any density, it is typically used to code the unnormalized posterior log density of a Bayesian mode.  Densities are read elementwise, with scalar arguments being broadcast where necessary.  With this translation, the unnormalized log posterior over the constrained variables defined by the Stan program's model block is
$$
\log p(\alpha, \beta, \sigma \mid x, y)
 =  \log \textrm{normal}(\alpha \mid 0, 5)
 +  \sum_{p=1}^P \textrm{normal}(\beta_p \mid 0, 2.5) \\
 +  \log \textrm{gamma}(\sigma \mid 0.5) 
 +  \sum_{n=1}^N \textrm{normal}(y_n \mid \alpha + \beta \cdot x_n, \sigma).
$$
The corresponding unconstrained log density over which inference is performed, adds the log Jacobian adjustment for the change of variables,
$$
\log p(\alpha, \beta, \sigma^\text{u} \mid x, y)
= \log p(\alpha, \beta, \exp(\sigma^\text{u}) \mid x, y) + \sigma^\text{u}.
$$

The transpiled C++ code implementing the log density function performs the following sequence of operations, which directly follows the Stan program.  The typing, logging, debugging traces, message I/O, and name mangling have all been simplified.  

```cpp
template <bool propto, bool jacobian, typename T>
inline auto log_prob(Vector<T>& params) const {
  Accumulator<T> accum;
  
  // transpiled parameters block
  T log_jacobian;
  Deserializer<T> in(params)
  auto alpha = in.template read<T>();
  auto beta = in.template read<Vector<T>>(P);
  auto sigma = in__.template read_constrain_lb<T, jacobian>(0, log_jacobian);
  accum.add(log_jacobian);

  // transpiled model block
  accum.add(normal_lpdf<propto>(alpha, 0, 5));
  accum.add(normal_lpdf<propto>(beta, 0, 2.5));
  accum.add(exponential_lpdf<propto>(sigma, 0.5));
  accum.add(normal_lpdf<propto>(y, add(alpha, multiply(beta, x))), sigma);

  return accum.sum();
}
```

The `read` methods of the deserializer read the next variable fromn the sequence of parameters, perform any necessary constraining transform and add any Jacobian adjustment to `lp`, controlled by the flag `jacobian`.  Arithmetic in the Stan program is replaced with overloaded internal library calls `add` and `multiply` which can handle vectors and scalars.  There is implicit broadcasting and internal summation in the `normal_lpdf` log density function.  When applied to a vector like `beta` or `y`, it sums the log densities of the components, broadcasting any scalar arguments as necessary.  The accumulator collects terms and then its method `sum` returns a flattened autodiff tree with a single root pointing to all the terms with implicit unit derivatives.

To support the changes of variables for reporting constrained output, the compiled C++ code exposes the constraining transform and its Jacobians. For initialization from constrained parameters, there is a matching unconstraining transform.  The model class also supplies methods for determining the shape and names of the constrained and unconstrained parameters.

The final component of a compiled Stan model is a function to perform predictive inference as defined by the generated quantities block (this can also be done post-hoc with a new program and generated quantities block).  In particular, the model compiles a generated quantities function that takes a random number generator and produces the output defined in the generated quantities block purely by forward sampling without the need for any automatic differentiation.


# Coding models in JAX

Now that we have the low-level target C++ code for a Stan program, we are going to translate the C++ to JAX.  Then we will build back up to a higher-level abstraction and our JAX code will look very similar to our Stan code.

## Linear regression example coded directly in JAX

Here's a definition of our linear regression model in JAX.  The naming should make it clear how it corresponds to the C++ model produced by the Stan transpiler from the Stan program.

```{python python-code}
#| code-fold: false
import jax.numpy as jnp
from jax.scipy import stats

# data omitted (jnp.arrays)
x = ... 
y = ... 

# constrained; closes over data x, y
def log_joint(alpha, beta, sigma):
    lp = 0
    
    # prior
    lp += jnp.sum(stats.norm.logpdf(alpha, loc=0.0, scale=1.0))
    lp += jnp.sum(stats.norm.logpdf(beta, loc=0.0, scale=1.0))
    lp += jnp.sum(stats.expon.logpdf(sigma, scale=1.0))

    # likelihood
    mu = alpha + x @ beta
    lp += jnp.sum(stats.norm.logpdf(y, loc=mu, scale=sigma))

    return lp

# unconstrained
def log_prob(alpha, beta, sigma_unc):
    lp_jacobian = 0
    sigma = jnp.exp(sigma_unc)
    lp_jacobian += sigma_unc
    
    lp_joint = log_joint(alpha, beta, sigma)
    
    return lp_jacobian + lp_joint
```

There are a few differences from Stan and its C++.

1.  There are no data declarations.  The function `log_joint` closes over the data variables `x` and `y` (i.e., it reads them from the environment where it was defined); we will shortly show how to abstract this into a function.
2.  JAX does not require parameters to be serialized. With the wizardry of PyTree, the Blackjax and many JAX-based packages can work directly with the `log_prob` function without any need for serialization of the parameters into a flattened array.  If serialized log density functions _are_ needed elsewhere, they are convertible with a single function call as we show below.
3.  There is no need to work with accumulators---JAX's just-in-time compilation is sufficient to optimize sequeces of operations at the XLA substrate to which JAX is compiled.
4.  The `log_joint` function where the user defines a model is defined over constrained parameters, whereas the `log_prob` function is defined over unconstrained parameters; this mirrors Stan directly rather than its compiled C++ code, which does not define the joint density as a function.
5.  As presented above, there is not any 'generated quantities'-like behavior. One advantage of coding the model in a consistent language like Python is that these forward sampling functions are more or less the same as any other function of the draws, and can be written later than (or indeed, entirely separately from) the log density.  That being said, we will show how a user who wants to give special place to some 'generated quantities' behavior in their workflow can do so in the following sections.

Because it is just Python code, we could break the JAX model code down into calls to a log prior and log likelihood function.  Here, we have stuck to the Stan coding conventions to help make the translation clearer.  Other parts of the code may also be broken out into function calls.  There is no need for a separate block to declare functions---plain old Python functions can be used to evaluate JAX calls.

The `log_joint` function corresponds to the Stan model block and is defined over constrained parameters. The `log_prob` function, on the other hand, is defined for unconstrained parameters, as in the compiled C++ code for a Stan program.  Like in the Stan `log_prob` function in C++, the `log_prob` function here first transforms unconstrained parameters to constrained and collects their Jacobians.  Then it calls the code that matches the Stan model block, i.e., `log_joint`.  The return is just the log Jacobian plus log joint density, just as in Stan.  In the call from `log_prob`, `sigma` will be positive by construction.

Aside from the verbosity of all the namespace qualifiers and the need for all the intermediate calls to `sum`, the biggest obstacle to writing code this way is having to manually deal with the constraining and unconstraining transform.


## Linear regression in JAX with `densejax`

The Stan linear regression can be translated almost line for line into Python using `densejax`.

```python
from densejax import (
    real, positive, normal, exponential, normal_rng, model
)

def linear_regression(x, y, x_new):
    N, P = x.shape
    
    parameters = {
      'a': real(),
      'b': real(size=P),
      's': positive()
    }                   

    def log_density(a, b, s):
        lp = 0
        lp += normal(a, 0, 2)
        lp += normal(b, 0, 1)
        lp += exponential(s, 0.5)
        lp += normal(y, a + x @ b, s)
        return lp

    def generate(rng, a, b, s):
        y_new = normal_rng(rng, a + x_new @ b, s)
        return { 'y_new': y_new }
        
    return model(parameters, log_density, generate)
```

The resulting `model` object mirrors the C++ object produced by Stan and also the model object produced by BridgeStan [@roualdes2023bridgestan].  Because these simple functions generate fully JAX-embedded code, the log density function can be automatically differentiated and all of the functions can be just-in-time compiled.

The parameter declarations with constraints, such as `positive`.  That allows it to be used for inference by `blackjax`, which has ported NUTS and ADVI from Stan into JAX and much much more.



# References {.unnumbered}

::: {#refs}
:::
